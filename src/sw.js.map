{"version":3,"file":"sw.js","names":["PushData","version","console","log","self","addEventListener","e","notification","close","data","waitUntil","clients","openWindow","url","_e$data","pushData","json","notificationOptions","guard","body","requireInteraction","silent","icon","title","promise1","registration","showNotification","promise2","matchAll","then","forEach","client","_e$data2","postMessage","Promise","all"],"sources":["sw.ts"],"sourcesContent":["/// <reference no-default-lib=\"true\"/>\n/// <reference lib=\"esnext\" />\n/// <reference lib=\"webworker\" />\n\nimport { PushData } from \"./PushData\";\n\nexport type { };\n\n// NOTE: We must export or import at least one thing so we are not in\n// the \"global\" scope, but in a module scope which is re-declarable.\n//\n// The error from tsserver is: 2451: Cannot redeclare block-scoped\n// variable 'self'.\n//\n// Even though this is not really a module and cannot be: ServiceWorkers\n// cannot be modules.\n\n\n\ntype Version = number\n\nconst version: Version = 35\n\ndeclare const self: ServiceWorkerGlobalScope;\n\nconsole.log('Custom service worker functions for pr-webrtc: version=', version);\n\nself.addEventListener('notificationclick', e => {\n  e.notification.close();\n\n  if ('url' in e.notification.data) {\n    // console.log('self.origin', self.origin);\n\n    e.waitUntil(\n      self.clients.openWindow(e.notification.data.url)\n    );\n\n    // old:\n    // const p = self.clients.matchAll({ type: \"window\", includeUncontrolled: true }).then(c => {\n    //     // let couldFocus = false;\n    //     for (let client of c) {\n    //         if (client instanceof WindowClient) {\n    //             // console.log('instanceof WindowClient', client);\n    //             if ('focus' in client && typeof client.focus === 'function') {\n    //                 try {\n    //                     return client.focus().catch(reason => {\n    //                         console.error(reason, 'for client', client);\n    //                     });\n    //                     // couldFocus = true;\n    //                     // console.log('focus successful for client', client);\n    //                 } catch (reason) {\n    //                     console.error(reason, 'for client', client);\n    //                 }\n    //             } else {\n    //                 console.warn('no focus method in client');\n    //             }\n    //         } else {\n    //             // console.log('not instanceof WindowClient', client);\n    //         }\n    //         // console.log('client', client);\n\n    //     }\n\n    //     // if (!couldFocus) {\n    //     // console.log('open window for url', e.notification.data.url)\n    //     return self.clients.openWindow(e.notification.data.url).catch(reason => {\n    //         console.error(reason);\n    //     });\n    //     // }\n    // })\n\n    // e.waitUntil(p)\n  }\n\n})\n\n// TODO funktioniert fuer Apple zumindest IOS nur wenn die App auf dem Homescreen gespeichert wurde.\n// Zumindest laut MDN Dokumentation: https://developer.mozilla.org/en-US/docs/Web/API/PushEvent\n// Fuer Apple Handys:\n// \"Notifications are supported in web apps saved to the home screen.\"\n// (siehe: https://developer.mozilla.org/en-US/docs/Web/API/PushEvent)\n\n// TODO evtl mal systematisch austesten ob diese datei ueberhaupt ausgefuehrt wird indem nur auf antworten gewartet wird\nself.addEventListener('push', (e) => {\n\n  // console.log('push event: e=', e);\n  const pushData = e.data?.json();\n  // console.log('e.data?.json()', pushData)\n  // if (!PushData.guard(pushData)) {\n  //     console.error('Unexpected pushData', pushData)\n  //     return;\n  // }\n  const notificationOptions: NotificationOptions = PushData.guard(pushData) ? {\n    body: pushData.body,\n    data: { url: pushData.url },\n    // tag: 'pr-webRTC call',\n    requireInteraction: true,\n    silent: false,\n    icon: pushData.icon,\n    // icon: '/accept-call-64x64.png'\n  } : {\n    body: 'Unexpected push event (pr-webrtc)',\n    // silent: false,\n    // icon: '/accept-call-64x64.png'\n  }\n  const title = PushData.guard(pushData) ? pushData.title : 'Fehlerhafte PushMsg';\n  const promise1 = self.registration.showNotification(title, notificationOptions);\n  const promise2 = self.clients.matchAll().then(clients => {\n    // console.log('clients.length', clients.length);\n    clients.forEach(client => {\n      // console.log('sending push to', client);\n      client.postMessage(e.data?.json());\n    })\n  })\n  e.waitUntil(Promise.all([promise1, promise2]))\n})\n"],"mappings":"AAIA,OAASA,QAAQ,KAAQ,YAAY,CAiBrC,GAAM,CAAAC,OAAgB,CAAG,EAAE,CAI3BC,OAAO,CAACC,GAAG,CAAC,yDAAyD,CAAEF,OAAO,CAAC,CAE/EG,IAAI,CAACC,gBAAgB,CAAC,mBAAmB,CAAEC,CAAC,EAAI,CAC9CA,CAAC,CAACC,YAAY,CAACC,KAAK,CAAC,CAAC,CAEtB,GAAI,KAAK,EAAI,CAAAF,CAAC,CAACC,YAAY,CAACE,IAAI,CAAE,CAGhCH,CAAC,CAACI,SAAS,CACTN,IAAI,CAACO,OAAO,CAACC,UAAU,CAACN,CAAC,CAACC,YAAY,CAACE,IAAI,CAACI,GAAG,CACjD,CAqCF,CAEF,CAAC,CAAC,CASFT,IAAI,CAACC,gBAAgB,CAAC,MAAM,CAAGC,CAAC,EAAK,KAAAQ,OAAA,CAGnC,GAAM,CAAAC,QAAQ,EAAAD,OAAA,CAAGR,CAAC,CAACG,IAAI,UAAAK,OAAA,iBAANA,OAAA,CAAQE,IAAI,CAAC,CAAC,CAM/B,GAAM,CAAAC,mBAAwC,CAAGjB,QAAQ,CAACkB,KAAK,CAACH,QAAQ,CAAC,CAAG,CAC1EI,IAAI,CAAEJ,QAAQ,CAACI,IAAI,CACnBV,IAAI,CAAE,CAAEI,GAAG,CAAEE,QAAQ,CAACF,GAAI,CAAC,CAE3BO,kBAAkB,CAAE,IAAI,CACxBC,MAAM,CAAE,KAAK,CACbC,IAAI,CAAEP,QAAQ,CAACO,IAEjB,CAAC,CAAG,CACFH,IAAI,CAAE,mCAGR,CAAC,CACD,GAAM,CAAAI,KAAK,CAAGvB,QAAQ,CAACkB,KAAK,CAACH,QAAQ,CAAC,CAAGA,QAAQ,CAACQ,KAAK,CAAG,qBAAqB,CAC/E,GAAM,CAAAC,QAAQ,CAAGpB,IAAI,CAACqB,YAAY,CAACC,gBAAgB,CAACH,KAAK,CAAEN,mBAAmB,CAAC,CAC/E,GAAM,CAAAU,QAAQ,CAAGvB,IAAI,CAACO,OAAO,CAACiB,QAAQ,CAAC,CAAC,CAACC,IAAI,CAAClB,OAAO,EAAI,CAEvDA,OAAO,CAACmB,OAAO,CAACC,MAAM,EAAI,KAAAC,QAAA,CAExBD,MAAM,CAACE,WAAW,EAAAD,QAAA,CAAC1B,CAAC,CAACG,IAAI,UAAAuB,QAAA,iBAANA,QAAA,CAAQhB,IAAI,CAAC,CAAC,CACnC,CAAC,CACH,CAAC,CAAC,CACFV,CAAC,CAACI,SAAS,CAACwB,OAAO,CAACC,GAAG,CAAC,CAACX,QAAQ,CAAEG,QAAQ,CAAC,CAAC,CAC/C,CAAC,CAAC","ignoreList":[]}